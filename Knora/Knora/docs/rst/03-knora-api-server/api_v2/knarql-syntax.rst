.. Copyright © 2015 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
   Tobias Schweizer, André Kilchenmann, and Sepideh Alassi.

   This file is part of Knora.

   Knora is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published
   by the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Knora is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Affero General Public License for more details.

   You should have received a copy of the GNU Affero General Public
   License along with Knora.  If not, see <http://www.gnu.org/licenses/>.

.. _knarql-syntax-v2:

KnarQL: Knora Query Language
============================

.. contents:: :local:

-------------
Basic Concept
-------------

KnarQL is intended to offer the advantages of SPARQL endpoints (particularly the ability to perform queries using complex search criteria) while avoiding their drawbacks in terms of performance and security (see `The Enduring Myth of the SPARQL Endpoint`_). It also has the benefit of enabling clients to work with a simpler RDF data model than the one Knora actually uses to store data in the triplestore, and makes it possible to provide better error-checking.

Rather than being processed directly by the triplestore, a KnarQL query is interpreted by the Knora API server, which enforces certain restrictions on the query, and implements paging and permission checking. The API server generates SPARQL based on the KnarQL query submitted, queries the triplestore, filters the results according to the user's permissions, and returns each page of query results as a Knora API response. Thus, KnarQL is a hybrid between a RESTful API and a SPARQL endpoint.

A KnarQL query conforms to a subset of the syntax of a SPARQL CONSTRUCT_ query, with some additional restrictions and functionality. In particular, the variable representing the top-level (or 'main') resource that will appear in each search result must be identified, statements must be included to specify the types of the entities being queried, OFFSET is used to control paging, and ORDER BY is used to sort the results.

It is certainly possible to write KnarQL queries by hand, but we expect that in general, they will be automatically generated by client software, e.g. by a client user interface.

****************************
Main and Dependent Resources
****************************

The main resource is the top-level resource in a search result. Other resources that are in some way connected to the main resource are referred to as dependent resources. If the client asks for a resource A relating to a resource B, then all matches for A will be presented as main resources and those for B as dependent resources.

********************************
Graph Patterns and Result Graphs
********************************

The WHERE clause of a KnarQL query specifies a graph pattern. Each query result will match this graph pattern, and will have the form of a graph whose starting point is a main resource. The query's graph pattern, and hence each query result graph, can span zero more levels of relations between resources. For example, a query could request articles by authors who were students of a particular professor. Or authors of texts that refer to events that took place within a certain date range.

*******************
Permission Checking
*******************

Each matching resource is returned only if the client has permission to see all the values of that resource that matched the criteria given in the WHERE clause. If a matching resource contains a value that was mentioned in the WHERE clause, but the client does not have permission to see that value, the resource is not returned in the results, and is instead replaced by a proxy resource called ``knora-api:ForbiddenResource``.

*********
Inference
*********

KnarQL queries are understood to imply RDFS reasoning. Depending on the triplestore being used, this may be implemented using the triplestore's own reasoner or by query expansion in the Knora API server (using SPARQL property path syntax). This means that if a statement pattern specifies a property, the pattern will also match subproperties of that property.

**********
API Schema
**********

A KnarQL query must be written using the Knora API simple schema (see :ref:`querying-and-creating-ontologies-v2`). However, results can be returned in the simple or complex schema. (The ability to choose the response schema is not yet implemented, so for now, results are always returned in the complex schema.)

-------------
KnarQL Syntax
-------------

Every KnarQL query is a valid SPARQL 1.1 CONSTRUCT_ query. However, KnarQL only supports a subset of the elements that can be used in a SPARQL Construct query. Additionally, KnarQL requires the client to use explicit type annotations, explained below; these are valid SPARQL, but specific to the Knora API. Also, the main resource has to be marked.

************
WHERE Clause
************

The WHERE clause specifies a graph pattern to be matched, i.e. the search criteria. Resources that match the given criteria, and that the client has permission to see, will be returned.

Supported SPARQL Syntax
***********************

The current version of KnarQL accepts CONSTRUCT queries whose WHERE clauses use the following patterns, with the specified restrictions:
 - OPTIONAL: cannot be nested in an OPTIONAL or UNION.
 - UNION: cannot be nested in an OPTIONAL or UNION.
 - FILTER: may contain a complex expression using the Boolean operators AND and OR, as well as comparison operators. The left argument of a comparison operator must be a query variable.
 - FILTER NOT EXISTS
 - OFFSET: the OFFSET is needed for paging. It does not actually refer to the number of triples to be returned, but to the requested page of results. The default value is 0, which refers to the first page of results. The number of results per page is defined in ``app/v2`` in ``application.conf``.
 - ORDER BY: In SPARQL, the result of a Construct query is an unordered set of triples. However, a KnarQL query returns an ordered list of resources, which can be ordered by the values of specified properties.

Resources
*********

Resources can be represented by an IRI or a query variable.

Properties
**********

Properties can be represented by an IRI or a query variable. If a property is represented by a query variable, it can be restricted to certain property IRIs using a FILTER.

Values
******

Values can only be represented by a query variable. Value literals are currently not supported as the objects of statement patterns in the query. To restrict a value, a FILTER must be used. Without a FILTER, all the instances of a value are returned.

Required Type Annotations
*************************

Resources, properties, and values must be accompanied by explicit type annotation statements. [1]_

There are two type annotation properties:
 - ``knora-api:objectType``: indicates the type of value or resource that a property points to.
 - ``rdf:type``: indicates the type of a resource or value.

Property Types
**************

A property may point either to a value or to a resource. In the first case, it is called a value property, in the second case a linking property. The type annotation property ``knora-api:objectType`` indicates the type of value or resource the property points to.

Value Property Types
^^^^^^^^^^^^^^^^^^^^

Supported value property types:
 - ``xsd:string``
 - ``xsd:integer``
 - ``xsd:decimal``
 - ``xsd:boolean``
 - ``knora-api:Date``
 - ``knora-api:StillImageFile``
 - ``knora-api:Geom``

Linking Property Types
^^^^^^^^^^^^^^^^^^^^^^

A linking property has to be annotated with the type ``knora-api:Resource``. Since inference is assumed, this matches any resource. To restrict the types of resources, additional statements can be made using ``rdfs:type``. The linking property can also be restricted using a FILTER in case a query variable is used.

Value Types
***********

Value types are used to indicate the type of a value (``rdf:type``).
KnarQL supports the following types of value instances:

 - ``xsd:string``
 - ``xsd:integer``
 - ``xsd:decimal``
 - ``xsd:boolean``
 - ``knora-api:Date``
 - ``knora-api:StillImageFile``
 - ``knora-api:Geom``

However, not all of these types are supported in FILTERs to restrict values. Supported value types in FILTERs:

 - ``xsd:string``
 - ``xsd:integer``
 - ``xsd:decimal``
 - ``xsd:boolean``
 - ``knora-api:Date``

****************
CONSTRUCT Clause
****************

The CONSTRUCT clause specifies which information the response should return.
The CONSTRUCT clause must contain at least one statement, specifying ``knora-api:isMainResource``. Any other statements in the CONSTRUCT clause must also be present in the WHERE clause.

Marking the Main Resource
*************************

In the CONSTRUCT clause of a KnarQL query, the variable representing the main resource that the user is interested in must be indicated with ``knora-api:isMainResource true``. Exactly one variable representing a resource must be marked in this way.

-----------------
KnarQL by Example
-----------------

In this section, we provide some sample queries of different complexity to illustrate the usage of KnarQL.

*************************************************
Getting all the Components of a Compound resource
*************************************************

In order to get all the components of a compound resource, the following KnarQL query can be sent to the API.

In this case, the compound resource is an ``incunabula:book`` identified by the IRI ``http://data.knora.org/c5058f3a`` and the components are of type ``incunabula:page`` (test data for the Incunabula project).
Since inference is assumed, we can use ``knora-api:StillImageRepresentation`` (``incunabula:page`` is one of its subclasses).
This makes the query more generic and allows for reuse (for instance, a client would like to query different types of compound resources defined in different ontologies).

ORDER BY is used to sort the components by their sequence number.

OFFSET is set to 0 to get the first page of results.

Note that in a KnarQL query, the prefix ``knora-api`` refers to the Knora-Api simple schema.

::

   PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#>

   CONSTRUCT {
      ?component knora-api:isMainResource true . # marking of the component searched for as the main resource, required
      ?component knora-api:seqnum ?seqnum . # return the sequence number in the response
      ?component knora-api:hasStillImageFileValue ?file . # return the StillImageFile in the response
   } WHERE {
      ?component a knora-api:Resource . # explicit type annotation for the component searched for, required
      ?component a knora-api:StillImageRepresentation . # additional restriction of the type of component, optional

      ?component knora-api:isPartOf <http://data.knora.org/c5058f3a> . # component relates to compound resource via this property
      knora-api:isPartOf knora-api:objectType knora-api:Resource . # type annotation for linking property, required
      <http://data.knora.org/c5058f3a> a knora-api:Resource . # type annotation for compound resource, required

      ?component knora-api:seqnum ?seqnum . # component must have a sequence number, no further restrictions given
      knora-api:seqnum knora-api:objectType xsd:integer . # type annotation for the value property, required
      ?seqnum a xsd:integer . # type annotation for the sequence number, required

      ?component knora-api:hasStillImageFileValue ?file . # component must have a StillImageFile, no further restrictions given
      knora-api:hasStillImageFileValue knora-api:objectType knora-api:StillImageFile . # type annotation for the value property, required
      ?file a knora-api:StillImageFile . # type annotation for the StillImageFile, required
   }
   ORDER BY ASC(?seqnum) # order by sequence number, ascending
   OFFSET 0 #get first page of results


The ``incunabula:book`` with the IRI ``http://data.knora.org/c5058f3a`` has 402 pages (this result can be obtained by doing a count query, see :ref:`reading-and-searching-resources-v2`). However, with ``OFFSET 0``, only the first page of results is returned. The same query can be sent again with ``OFFSET 1`` to get the next page of results, and so forth.  When a page of results is not full (see settings in ``app/v2`` in ``application.conf``) or is empty, no more results are available.

By design, it is not possible for the client to get more than one page of results at a time; this is intended to prevent performance problems that would be caused by huge responses. A client that wants to download all the results of a query must request each page sequentially.

Let's assume the client is not interested in all of the book's pages, but just in first ten of them. In that case, the sequence number can be restricted using a FILTER that is added to the query's WHERE clause:

::

   FILTER (?seqnum <= 10)

The first page starts with sequence number 1, so with this FILTER only the first ten pages are returned.

.. _The Enduring Myth of the SPARQL Endpoint: https://daverog.wordpress.com/2013/06/04/the-enduring-myth-of-the-sparql-endpoint/
.. _CONSTRUCT: https://www.w3.org/TR/sparql11-query/#construct
.. [1] In a future version, this type information could be inferred rather than explicitly given in the query.
